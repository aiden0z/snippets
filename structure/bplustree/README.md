# B+ 树

* 根节点至少包含两个子节点；
* 根节点到每个叶子节点的高度一致（叶子节点都在同一层）；
* 任意节点最多包含 m-1 个关键字 key，最少 ⌈m/2⌉-1 （m/2 向上取整减 1, 或最少 m/2 向下取整）个关键字 key；
* 每个节点中的关键字都按从小到大顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它
* 非根节点最多可以包含 m 个子节点，和至少 m/2 个子节点；
* 叶子节点包含了所有的关键字 key 信息和真正存储的数据信息，非叶子节点只有关键字信息，没有数据信息；
* 所有叶子节点类似链表一样链接在一起；

## 应用场景

很多数据库都基于 B+ 树实现索引。基于以下几个特性：

1. 只有叶子节点存储数据，或指向数据存储地址；
2. 整颗树高度较小，查找节点时 IO 次数更少，节省时间；
3. 叶子节点有序链接，能快速进行范围内查询；


## 实现细节

1. 有最大的 度 限制，也就是每个节点包含的最大子节点数；
2. 子节点通常有指针指向父节点；
3. 通常在 B+ 树实现是有两个指针分别用于指向根节点和关键字最小的叶子节点。这样就可以对 B+ 树进行两种搜索，一种是从最小关键字开始顺序查找，另一种是从根节点开始；

### 搜索 Key

### 插入 Key

插入节点分为两种情况：

#### Case 1

1. 如果叶子节点未满，则找到插入位置直接插入即可；

#### Case 2

1. 如果叶子节点已满，则找到插入位置插入节点，并按以下方式调整；
2. 将节点在 m/2 位置分割为两个节点；
3. 将 m/2 位置的关键字移到父节点；
4. 如果父节点也满了，则重复 2 到 3 步；

### 删除 Key

如果叶子节点中没有相应的 key 则删除失败，否则执行以下步骤。

1. 删除如果叶子节点中对应的 key。删除后若节点中的 key 的数量满足要求，则删除结束。否则执行第 2 步；
2. 若兄弟节点 key 有富余（满足最低数量要求），向兄弟节点借一个记录 key，同时用借到的 key 替换父节点（指当前节点和兄弟节点共同的父节点）中的 key，删除结束。否则执行第 3 步；
3. 若兄弟节点中没有富余的 key，则当前节点和兄弟节点合并成一个新的叶子节点，并删除父节点中的 key（父节点中的这个 key 两边的孩子指针就变成了一个指针，正好指向这个新的叶子节点），将当前节点指向父节点，执行第 4 步；
4. 若索引节点的 key 的数量满足最低要求，则删除操作结束。否则执行第 5 步；
5. 若兄弟节点有富余，父节点 key 下移，兄弟节点 key 上移，删除结束。否则执行第 6 步；
6. 当前节点和兄弟节点及父节点下移 key 合并成一个新的节点。将当前节点指向父节点，重复第 4 步；

## 参考
1. https://www.cnblogs.com/nullzx/p/8729425.html
2. https://www.programiz.com/dsa/b-plus-tree